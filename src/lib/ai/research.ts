import { ai } from '../../ai/ai.server';
import { z } from 'genkit';
import { Document } from 'genkit/retriever';
import { redisIndexer, redisRankedRetriever, redisRetriever, resetCache } from '$lib/redis';
import { db } from '../../db/db.server';
import { queries, querySteps, sources } from '../../db/schema';
import { eq } from 'drizzle-orm';
import { runPromptStream } from '$lib/utils/streaming';
import {
	ResearchOrchestratorChunkSchema,
	ResearchOrchestratorInputSchema,
	ResearchOrchestratorOutputSchema
} from './prompts/research/orchestrator';
import {
	ResearchAgentInputSchema,
	ResearchAgentOutputSchema,
	ResearchAgentChunkSchema
} from './prompts/research/researchAgent';
import {
	ResponseAgentChunkSchema,
	ResponseAgentInputSchema,
	ResponseAgentOutputSchema
} from './prompts/research/responseAgent';

const ResearchInputSchema = z.object({
	responseModel: z.object({
		model: z.string(),
		provider: z.string()
	}),
	query: z.string().describe('The research query to be processed by the AI agents.'),
	queryId: z.number().describe('The ID of the query in the database'),
	messages: z
		.object({
			content: z
				.object({
					text: z.string().describe('The content of the message.')
				})
				.array(),
			role: z.enum(['user', 'model', 'system']).describe('The role of the message author.')
		})
		.array()
		.describe('The thread of previous queries and results, if any.')
		.optional()
});

const ResearchStreamSchema = z.object({
	steps: z
		.array(
			z.object({
				step: z.string(),
				content: z.array(z.string().optional()).optional()
			})
		)
		.describe('The steps taken during the research process.')
		.optional(),
	sources: z
		.array(
			z.object({
				title: z.string(),
				url: z.string(),
				description: z.string().optional()
			})
		)
		.describe('The sources used in the final report.')
		.optional(),
	response: z.string().describe('The final response generated by the AI agents.').optional()
});

const ResearchOutputSchema = z.object({
	steps: z
		.array(
			z.object({
				step: z.string(),
				content: z.array(z.string().optional()).optional()
			})
		)
		.describe('The steps taken during the research process.'),
	sources: z
		.array(
			z.object({
				title: z.string(),
				url: z.string(),
				description: z.string().optional()
			})
		)
		.describe('The sources used in the final report.'),
	response: z.string().describe('The final response generated by the AI agents.')
});

interface Step {
	step: string;
	content: string[];
}

interface Source {
	title: string;
	url: string;
	description?: string;
}

export const researchFlow = ai.defineFlow(
	{
		name: 'researchFlow',
		inputSchema: ResearchInputSchema,
		streamSchema: ResearchStreamSchema,
		outputSchema: ResearchOutputSchema
	},
	async ({ responseModel, query, queryId, messages }, { sendChunk }) => {
		let steps: Step[] = [];

		const orchestratorOutput = await runPromptStream<
			z.infer<typeof ResearchOrchestratorInputSchema>,
			z.infer<typeof ResearchOrchestratorChunkSchema>,
			z.infer<typeof ResearchOrchestratorOutputSchema>
		>(
			'researchOrchestrator',
			{ query },
			{
				model: responseModel.provider + '/' + responseModel.model,
				messages: messages || []
			}
		);

		steps.push({
			step: 'Starting Research',
			content: [`Using ${orchestratorOutput.length} research agents.`]
		});
		sendChunk({ steps });

		try {
			await db.insert(querySteps).values({
				title: steps[0].step,
				content: JSON.stringify(steps[0].content),
				queryId
			});
		} catch (dbError) {
			console.error('Database error inserting step:', steps[0].step, dbError);
		}

		steps.push({ step: 'Finding Sources', content: [] });

		const documents: Document[] = [];

		let i = 0;
		for (const agent of orchestratorOutput) {
			const researchAgentOutput = await runPromptStream<
				z.infer<typeof ResearchAgentInputSchema>,
				z.infer<typeof ResearchAgentChunkSchema>,
				z.infer<typeof ResearchAgentOutputSchema>
			>(
				'researchAgent',
				{ prompt: agent.prompt, plan: agent.plan },
				{
					model: responseModel.provider + '/' + responseModel.model,
					maxTurns: 10
				},
				(chunk) => {
					if (chunk.result) {
						steps[1].content[i] = chunk.result;
						sendChunk({ steps });
					}
				}
			);

			steps[1].content[i] = researchAgentOutput.result;

			try {
				await db.insert(querySteps).values({
					title: steps[1].step,
					content: JSON.stringify(steps[1].content),
					queryId
				});
			} catch (dbError) {
				console.error('Database error inserting step:', steps[1].step, dbError);
			}

			for (const source of researchAgentOutput.sources) {
				const { name, url, content } = source;
				const localIndex = documents.length;
				try {
					const uniqueId = `${queryId}-${localIndex}`;
					const metadata = {
						id: uniqueId,
						title: name,
						url,
						flow: String(queryId)
					};
					const document = Document.fromText(content, metadata);

					documents.push(document);
				} catch (error) {
					console.error('Error saving data:', error);
				}
			}

			i++;
		}

		await ai.index({
			indexer: redisIndexer,
			documents
		});

		steps.push({ step: 'Writing Response', content: [] });

		let docs;
		try {
			docs = await ai.retrieve({
				retriever: redisRankedRetriever,
				query: { content: [{ text: query }], metadata: { flow: String(queryId) } } as any,
				options: {
					preRerankK: 1000,
					k: 200,
					extendPromptModel: responseModel,
					rerankerModel: responseModel
				}
			});
		} catch (err) {
			console.error('Error retrieving docs from redis retriever; using in-memory documents:', err);
			docs = documents;
		}

		let sites: Source[] = [];
		for (const doc of docs) {
			if (doc.content && doc.metadata && doc.metadata.title && doc.metadata.url) {
				sites.push({
					title: doc.metadata.title,
					url: doc.metadata.url,
					description: doc.content[0]?.text
				});
			}
		}
		sendChunk({ sources: sites });

		const insertPromises = sites.map((site) =>
			db.insert(sources).values({
				type: 'web',
				title: site.title,
				url: site.url,
				content: site.description || '',
				queryId
			})
		);
		const results = await Promise.allSettled(insertPromises);
		for (const r of results) if (r.status === 'rejected') console.error('Insert failed', r.reason);

		const responseAgentOutput = await runPromptStream<
			z.infer<typeof ResponseAgentInputSchema>,
			z.infer<typeof ResponseAgentChunkSchema>,
			z.infer<typeof ResponseAgentOutputSchema>
		>(
			'responseAgent',
			{ query },
			{
				model: responseModel.provider + '/' + responseModel.model,
				docs
			},
			(chunk) => {
				if (chunk.plan) {
					steps[2].content[0] = chunk.plan;
					sendChunk({ steps });
				}
				if (chunk.response) {
					sendChunk({
						response: chunk.response
					});
				}
			}
		);

		steps[2].content[0] = responseAgentOutput.plan;

		try {
			await db.insert(querySteps).values({
				title: steps[2].step,
				content: JSON.stringify(steps[2].content),
				queryId
			});
		} catch (dbError) {
			console.error('Database error inserting step:', steps[2].step, dbError);
		}

		try {
			await db
				.update(queries)
				.set({ result: responseAgentOutput.response })
				.where(eq(queries.id, queryId));
		} catch (dbError) {
			console.error('Database error updating query result:', dbError);
		}

		return {
			steps,
			sources: sites,
			response: responseAgentOutput.response
		};
	}
);
