import { ai } from '../../ai/ai.server';
import { z } from 'genkit';
import { Document } from 'genkit/retriever';
import { redisIndexer, redisRetriever, resetCache } from '$lib/redis';
import { db } from '../../db/db.server';
import { queries, querySteps, sources } from '../../db/schema';
import { eq } from 'drizzle-orm';
import { runPromptStream } from '$lib/utils/streaming';
import { OrchestratorChunkSchema, OrchestratorInputSchema, OrchestratorOutputSchema } from './prompts/research/orchestrator';
import { GenerateResearchPlanInputSchema, GenerateResearchPlanOutputSchema, GenerateResearchPlanChunkSchema } from './prompts/research/generateResearchPlan';
import { ResearchAgentInputSchema, ResearchAgentOutputSchema, ResearchAgentChunkSchema } from './prompts/research/researchAgent';
import { ResponseAgentChunkSchema, ResponseAgentInputSchema, ResponseAgentOutputSchema } from './prompts/research/responseAgent';

const ResearchInputSchema = z.object({
	responseModel: z.object({
		model: z.string(),
		provider: z.string()
	}),
	query: z.string().describe('The research query to be processed by the AI agents.'),
	queryId: z.number().describe('The ID of the query in the database'),
	messages: z
		.object({
			content: z
				.object({
					text: z.string().describe('The content of the message.')
				})
				.array(),
			role: z.enum(['user', 'model', 'system']).describe('The role of the message author.')
		})
		.array()
		.describe('The thread of previous queries and results, if any.')
		.optional()
});

const ResearchStreamSchema = z.object({
	steps: z
		.array(
			z.object({
				step: z.string(),
				content: z.array(z.string().optional()).optional()
			})
		)
		.describe('The steps taken during the research process.')
		.optional(),
	sources: z
		.array(
			z.object({
				title: z.string(),
				url: z.string(),
				description: z.string().optional()
			})
		)
		.describe('The sources used in the final report.')
		.optional(),
	response: z.string().describe('The final response generated by the AI agents.').optional()
});

const ResearchOutputSchema = z.object({
	steps: z
		.array(
			z.object({
				step: z.string(),
				content: z.array(z.string().optional()).optional()
			})
		)
		.describe('The steps taken during the research process.'),
	sources: z
		.array(
			z.object({
				title: z.string(),
				url: z.string(),
				description: z.string().optional()
			})
		)
		.describe('The sources used in the final report.'),
	response: z.string().describe('The final response generated by the AI agents.')
});

interface Step {
	step: string;
	content: string[];
}

interface Source {
	title: string;
	url: string;
	description?: string;
}

export const researchFlow = ai.defineFlow(
	{
		name: 'researchFlow',
		inputSchema: ResearchInputSchema,
		streamSchema: ResearchStreamSchema,
		outputSchema: ResearchOutputSchema
	},
	async ({ responseModel, query, queryId, messages }, { sendChunk }) => {
		let steps: Step[] = [];

		await resetCache();

		steps.push({ step: 'Starting Research', content: [] });

		const orchestratorOutput = await runPromptStream<
			z.infer<typeof OrchestratorInputSchema>,
			z.infer<typeof OrchestratorChunkSchema>,
			z.infer<typeof OrchestratorOutputSchema>
		>(
			'orchestrator',
			{ query },
			{
				model: responseModel.provider + '/' + responseModel.model,
				messages: messages || []
			},
			(chunk) => {
				if (chunk.plan) {
					steps[0].content[0] = chunk.plan;
					sendChunk({ steps });
				}
			}
		);

		steps[0].content[0] = orchestratorOutput.plan;

		const researchPrompts = orchestratorOutput.prompts || [];

		steps.push({ step: 'Planning Research', content: [] });
		steps.push({ step: 'Found Sources', content: [] });

		const documents: Document[] = [];

		let i = 0;
		for (const prompt of researchPrompts) {
			const researchPlanOutput = await runPromptStream<
				z.infer<typeof GenerateResearchPlanInputSchema>,
				z.infer<typeof GenerateResearchPlanChunkSchema>,
				z.infer<typeof GenerateResearchPlanOutputSchema>
			>(
				'generateResearchPlan',
				{ prompt: prompt },
				{
					model: responseModel.provider + '/' + responseModel.model
				},
				(chunk) => {
					if (chunk.plan) {
						steps[1].content[i] = chunk.plan;
						sendChunk({ steps });
					}
				}
			);

			const researchPlan = researchPlanOutput.plan;

			steps[1].content[i] = researchPlan;

			try {
				await db.insert(querySteps).values({
					title: steps[1].step,
					content: JSON.stringify(steps[1].content),
					queryId
				});
			} catch (dbError) {
				console.error('Database error inserting step:', steps[1].step, dbError);
			}

			const researchAgentOutput = await runPromptStream<
				z.infer<typeof ResearchAgentInputSchema>,
				z.infer<typeof ResearchAgentChunkSchema>,
				z.infer<typeof ResearchAgentOutputSchema>
			>(
				'researchAgent',
				{ prompt: prompt, plan: researchPlan },
				{
					model: responseModel.provider + '/' + responseModel.model
				},
				(chunk) => {
					if (chunk.result) {
						steps[2].content[i] = chunk.result;
						sendChunk({ steps });
					}
				}
			);
			
			steps[2].content[i] = researchAgentOutput.result;

			try {
				await db.insert(querySteps).values({
					title: steps[2].step,
					content: JSON.stringify(steps[2].content),
					queryId
				});
			} catch (dbError) {
				console.error('Database error inserting step:', steps[2].step, dbError);
			}

			for (const source of researchAgentOutput.sources) {
				const { name, url, content } = source;
				const id = documents.length;
				try {
					const metadata = {
						id,
						title: name,
						url
					};
					const document = Document.fromText(content, metadata);

					documents.push(document);
				} catch (error) {
					console.error('Error saving data:', error);
				}
			}

			i++;
		}

		await ai.index({
			indexer: redisIndexer,
			documents
		});

		steps.push({ step: 'Writing Response', content: [] });

		// const docs = await ai.retrieve({
		// 	retriever: redisRetriever,
		// 	query,
		// 	options: { k: 3 }
		// });

		const docs = documents;

		let sites: Source[] = [];
		for (const doc of docs) {
			if (doc.content && doc.metadata && doc.metadata.title && doc.metadata.url) {
				sites.push({
					title: doc.metadata.title,
					url: doc.metadata.url,
					description: doc.content[0]?.text
				});
			}
		}
		sendChunk({ sources: sites });

		const insertPromises = sites.map((site) =>
			db.insert(sources).values({
				type: 'web',
				title: site.title,
				url: site.url,
				content: site.description || '',
				queryId
			})
		);
		const results = await Promise.allSettled(insertPromises);
		for (const r of results) if (r.status === 'rejected') console.error('Insert failed', r.reason);

		const responseAgentOutput = await runPromptStream<
			z.infer<typeof ResponseAgentInputSchema>,
			z.infer<typeof ResponseAgentChunkSchema>,
			z.infer<typeof ResponseAgentOutputSchema>
		>(
			'responseAgent',
			{ query },
			{
				model: responseModel.provider + '/' + responseModel.model,
				docs
			},
			(chunk) => {
				if (chunk.plan) {
					steps[3].content[0] = chunk.plan;
					sendChunk({ steps });
				}
				if (chunk.response) {
					sendChunk({
						response: chunk.response
					});
				}
			}
		);

		steps[3].content[0] = responseAgentOutput.plan;

		try {
			await db.insert(querySteps).values({
				title: steps[3].step,
				content: JSON.stringify(steps[3].content),
				queryId
			});
		} catch (dbError) {
			console.error('Database error inserting step:', steps[3].step, dbError);
		}

		try {
			await db
				.update(queries)
				.set({ result: responseAgentOutput.response })
				.where(eq(queries.id, queryId));
		} catch (dbError) {
			console.error('Database error updating query result:', dbError);
		}

		return {
			steps,
			sources: sites,
			response: responseAgentOutput.response
		};
	}
);
